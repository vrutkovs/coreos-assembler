#!/usr/bin/python3 -u

'''
    This script removes previous builds. DO NOT USE on production pipelines
'''

import os
import sys
import argparse


from datetime import timedelta, datetime, timezone

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from cosalib.builds import Builds
from cosalib.prune import fetch_build_meta, delete_build

# Let's just hardcode this here for now
DEFAULT_KEEP_LAST_N = 3
DEFAULT_KEEP_LAST_DAYS = 7


parser = argparse.ArgumentParser(prog="coreos-assembler prune")
parser.add_argument("--workdir", default='.', help="Path to workdir")
parser.add_argument("--dry-run", help="Don't actually delete anything",
                    action='store_true')
parser.add_argument("--insert-only", metavar="BUILDID", action='store',
                    help="Append a new latest build, do not prune")
keep_options = parser.add_mutually_exclusive_group()
keep_options.add_argument("--keep-last-n", type=int, metavar="N",
                          default=DEFAULT_KEEP_LAST_N,
                          help="Number of untagged builds to keep (0 for all)")
keep_options.add_argument("--keep-last-days", metavar="N", type=int,
                          default=DEFAULT_KEEP_LAST_DAYS,
                          help="Keep untagged builds within number of days")
args = parser.parse_args()

keep_younger_than = None
if args.keep_last_days is not None:
    if args.keep_last_days <= 0:
        raise argparse.ArgumentTypeError("value must be positive: %d" %
                                         args.keep_last_days)
    keep_younger_than = (datetime.now(timezone.utc) -
                         timedelta(days=args.keep_last_days))

skip_pruning = (not keep_younger_than and args.keep_last_n == 0)
print("prune: skip_pruning: {skip_pruning}")

builds = Builds(args.workdir)
# collect all builds being pointed to by tags
tagged_builds = set([tag['target'] for tag in builds.raw().get('tags', [])])

# Handle --insert-only
if args.insert_only:
    builds.insert_build(args.insert_only)
    builds.flush()
    print("prune: --insert-only completed")
    sys.exit(0)

scanned_builds = []
for build in builds.raw()["builds"]:
    for arch in build['arches']:
        build = fetch_build_meta(build['id'], arch)
        if build:
            scanned_builds.append(build)

new_builds = []
builds_to_delete = []

# Don't prune known builds
if skip_pruning:
    new_builds = scanned_builds
else:
    if keep_younger_than:
        for build in scanned_builds:
            if build.id in tagged_builds:
                print(f"Skipping tagged build {build.id}")
                new_builds.append(build)
                continue

            if build.timestamp < keep_younger_than:
                builds_to_delete.append(build)
            else:
                new_builds.append(build)
    else:
        n = args.keep_last_n
        assert(n > 0)
        for build in scanned_builds:
            if n == 0:
                builds_to_delete.append(build)
            else:
                new_builds.append(build)
                n = n - 1

print(f"prune: new builds: {new_builds}")

# create a new builds list
builds.raw()['builds'] = []
for build in reversed(new_builds):
    for arch in build['arches']:
        builds.insert_build(build['id'], arch)

builds.bump_timestamp()

if len(builds_to_delete) == 0:
    print("prune: not removing any builds")
else:
    buildids = [x['id'] for x in builds_to_delete]
    print(f"prune: removing {' '.join(buildids)}")

# now delete other build dirs not in the manifest
error_during_pruning = False
for build in builds_to_delete:
    print(f"Pruning {build}")
    if not args.dry_run:
        try:
            delete_build(build)
        except Exception as e:
            error_during_pruning = True
            print(f"{e}")

if error_during_pruning:
    sys.exit(1)
